#!/usr/bin/env ruby

require 'optparse'
require 'time'
require 'iron_worker_ng'

class IronWorkerCLILoggerFormatter < ::Logger::Formatter
  def call(severity, time, proname, msg)
    msg = ' ' * 8 + msg unless msg.start_with? '------> '
    msg + "\n"
  end
end

@env = nil

def create_client
  IronCore::Logger.info 'IronWorkerNG', '------> Detecting Configuration'

  client = IronWorkerNG::Client.new(:env => @env)

  project = client.projects.get
  
  IronCore::Logger.info 'IronWorkerNG', "Working with project '#{project.name}' with id #{project.id}"

  client
end

def env_opt(opts)
  opts.on('-e', '--env ENV', 'environment') do |v|
    @env = v
  end
end

if $*.size == 1 && ($*[0] == '-v' || $*[0] == '--version')
  puts IronWorkerNG.full_version
  exit 0
end

if $*.size == 0 || (not ['upload', 'queue', 'schedule', 'log', 'run'].include?($*[0]))
  puts 'usage: iron_worker COMMAND [OPTIONS]'
  puts '    COMMAND: upload, queue, schedule, log, run'
  puts '    run iron_worker COMMAND --help to get more information about each command'
  exit 1
end

command = $*.shift

IronCore::Logger.logger.formatter = IronWorkerCLILoggerFormatter.new

if $*.include?('--debug')
  IronCore::Logger.logger.level = ::Logger::DEBUG

  $*.reject! { |p| p == '--debug' }
end

if command == 'upload'
  name = nil
  options = {}

  opts = OptionParser.new do |opts|
    opts.banner = "usage: iron_worker upload <name or path to workerfile> [OPTIONS]"

    opts.on('-n', '--name NAME', 'override for code name') do |v|
      name = v
    end

    opts.on('-c', '--max-concurrency CONCURRENCY', Integer, 'max number of concurrent workers for this code package') do |v|
      options[:max_concurrency] = v
    end

    env_opt(opts)
  end

  begin
    opts.parse!
  rescue OptionParser::ParseError
    puts $!.to_s
    exit 1
  end

  unless $*.size == 1
    puts 'Single argument expected!'
    puts opts
    exit 1
  end

  client = create_client

  IronCore::Logger.info 'IronWorkerNG', '------> Discovering .worker file'

  code = IronWorkerNG::Code::Base.new($*.first)
  code.name(name) if name

  IronCore::Logger.info 'IronWorkerNG', "Code package name has been set to '#{code.name}'"

  IronCore::Logger.info 'IronWorkerNG', '------> Uploading code package'

  code_id = client.codes.create(code, options).id

  IronCore::Logger.info 'IronWorkerNG', "Code package uploaded with id = #{code_id}"

  code_info = client.codes.get(code_id)

  IronCore::Logger.info 'IronWorkerNG', "------> Code package deployed with revision #{code_info.rev}"

  IronCore::Logger.info 'IronWorkerNG', "https://hud.iron.io/tq/projects/#{client.api.project_id}/code/#{code_id}"

elsif command == 'queue' || command == 'schedule'
  payload = nil
  payload_file = nil

  priority = nil
  timeout = nil
  delay = nil

  start_at = nil
  end_at = nil
  run_times = nil
  run_every = nil

  print_id = false

  opts = OptionParser.new do |opts|
    opts.banner = "usage: iron_worker #{command} <code name> [OPTIONS]"

    opts.on('-p', '--payload PAYLOAD', String, 'payload to pass') do |v|
      payload = v
    end

    opts.on('-f', '--payload-file PAYLOAD_FILE', String, 'payload file to pass') do |v|
      payload_file = v
    end

    opts.on('--priority PRIORITY', Integer, '0 (default), 1, 2') do |v|
      priority = v
    end

    opts.on('--timeout TIMEOUT', Integer, 'maximum run time in seconds from 0 to 3600 (default)') do |v|
      timeout = v
    end

    opts.on('--delay DELAY', Integer, 'delay before start in seconds') do |v|
      delay = v
    end

    if command == 'schedule'
      opts.on('--start-at TIME', 'start task at specified time') do |v|
        start_at = Time.parse(v)
      end

      opts.on('--end-at TIME', 'stop running task at specified time') do |v|
        end_at = Time.parse(v)
      end

      opts.on('--run-times RUN_TIMES', Integer, 'run task no more times than specified') do |v|
        run_times = v
      end

      opts.on('--run-every RUN_EVERY', Integer, 'run task every RUN_EVERY seconds') do |v|
        run_every = v
      end
    end

    opts.on('--print-id', 'prints result id') do |v|
      print_id = true
    end

    env_opt(opts)
  end

  begin
    opts.parse!
  rescue OptionParser::ParseError
    puts $!.to_s
    exit 1
  end

  unless $*.size == 1
    puts 'Single argument expected!'
    puts opts
    exit 1
  end

  name = $*.first

  if payload.nil? and (not payload_file.nil?)
    payload = File.read(payload_file)
  end

  options = {}

  options[:priority] = priority unless priority.nil?
  options[:timeout] = timeout unless timeout.nil?
  options[:delay] = delay unless delay.nil?

  if command == 'schedule'
    options[:start_at] = start_at unless start_at.nil?
    options[:end_at] = end_at unless end_at.nil?
    options[:run_times] = run_times unless run_times.nil?
    options[:run_every] = run_every unless run_every.nil?
  end

  client = create_client

  id = nil

  if command == 'queue'
    IronCore::Logger.info 'IronWorkerNG', '------> Queueing task'

    id = client.tasks.create(name, payload, options).id

    IronCore::Logger.info 'IronWorkerNG', "------> Worker '#{name}' queued with task id #{id}"

    IronCore::Logger.info 'IronWorkerNG', "https://hud.iron.io/tq/projects/#{client.api.project_id}/jobs/#{id}"
  else
    IronCore::Logger.info 'IronWorkerNG', '------> Scheduling task'

    id = client.schedules.create(name, payload, options).id

    IronCore::Logger.info 'IronWorkerNG', "------> Worker '#{name}' scheduled with schedule id #{id}"

    IronCore::Logger.info 'IronWorkerNG', "https://hud.iron.io/tq/projects/#{client.api.project_id}/scheduled_jobs/#{id}"
  end

  IronCore::Logger.info 'IronWorkerNG', id if print_id
elsif command == 'log'
  live = false
  wait = false

  opts = OptionParser.new do |opts|
    opts.banner = "usage: iron_worker log <task id> [OPTIONS]"

    opts.on('-w', '--wait', 'wait for task') do |v|
      wait = true
    end

    env_opt(opts)
  end

  begin
    opts.parse!
  rescue OptionParser::ParseError
    puts $!.to_s
    exit 1
  end

  unless $*.size == 1
    puts 'Single argument expected!'
    puts opts
    exit 1
  end

  task_id = $*.first

  client = create_client

  IronCore::Logger.info 'IronWorkerNG', "------> Getting log of task #{task_id} (https://hud.iron.io/tq/projects/#{client.api.project_id}/jobs/#{task_id}/log)"

  log = ''

  if live
    begin
      log = client.tasks.log(task_id)
    rescue IronCore::Error
    end
  else
    if wait
      client.tasks.wait_for(task_id)
    end

    log = client.tasks.log(task_id)
  end

  print log

  if live
    client.tasks.wait_for(task_id) do |task|
      if task.status == 'running'
        begin
          next_log = client.tasks.log(task_id)
          print next_log[log.length .. - 1]
          log = next_log
        rescue IronCore::Error
        end
      end
    end

    begin
      next_log = client.tasks.log(task_id)
      print next_log[log.length .. - 1]
    rescue IronCore::Error
    end
  end
elsif command == 'run'
  payload = nil
  payload_file = nil

  opts = OptionParser.new do |opts|
    opts.banner = "usage: iron_worker run <name or path to workerfile> [OPTIONS]"

    opts.on('-p', '--payload PAYLOAD', String, 'payload to pass') do |v|
      payload = v
    end

    opts.on('-f', '--payload-file PAYLOAD_FILE', String, 'payload file to pass') do |v|
      payload_file = v
    end
  end

  begin
    opts.parse!
  rescue OptionParser::ParseError
    puts $!.to_s
    exit 1
  end

  unless $*.size == 1
    puts 'Single argument expected!'
    puts opts
    exit 1
  end

  if payload.nil? and (not payload_file.nil?)
    payload = File.read(payload_file)
  end

  IronCore::Logger.info 'IronWorkerNG', '------> Discovering .worker file'

  code = IronWorkerNG::Code::Base.new($*.first)

  IronCore::Logger.info 'IronWorkerNG', "------> Running Worker '#{code.name}'"
  
  code.run(payload)
end
